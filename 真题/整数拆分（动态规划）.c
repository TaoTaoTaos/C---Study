/*
题目要求：
输入一个数n ， 将其拆分n=n1+n2+.....的形式， n1、n2…>=1 ，
如6= 6/ 5+1/ 4+2/ 4+1+1/ 3+3/ 3+2+1/ 3+1+1+1/ 2+2+2/ 2+2+1+1/ 2+1+1+1+1/ 1+1+1+1+1+1
共十一种形式，输入一个正整数n，输出可拆分的形式有多少种

解题思路：
这是一个经典的动态规划问题，我们可以使用一个二维数组dp来存储中间结果。
dp[i][j]表示数字j的拆分方式中，最大的数字不超过i的拆分方式的个数。
初始化时，dp[i][0] = 1，表示数字0的拆分方式只有一种，就是不拆分。
状态转移方程为：
如果i > j，那么dp[i][j] = dp[i-1][j]，表示当前的i大于j，所以拆分方式与i-1时相同。
如果i <= j，那么dp[i][j] = dp[i-1][j] + dp[i][j-i]，表示当前的i小于等于j，所以拆分方式为i-1时的拆分方式和j-i时的拆分方式之和。
最后返回dp[n][n]即可。
*/

#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);  // 输入一个正整数n
    int dp[n+1][n+1];  // 定义动态规划数组

    // 初始化动态规划数组
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 1;  // 数字0的拆分方式只有一种，就是不拆分
    }

    // 动态规划求解
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (i > j) {
                dp[i][j] = dp[i-1][j];  // 当前的i大于j，所以拆分方式与i-1时相同
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-i];  // 当前的i小于等于j，所以拆分方式为i-1时的拆分方式和j-i时的拆分方式之和
            }
        }
    }

    printf("%d\n", dp[n][n]);  // 输出结果

    return 0;
}

/*
总结：
这个题目考察的是动态规划的知识点，通过构建一个二维数组dp，我们可以将问题拆解为更小的子问题，从而避免了重复计算，提高了效率。
关键注释：
1. "int dp[n+1][n+1];"：定义了一个二维数组dp，用于存储中间结果。dp[i][j]表示数字j的拆分方式中，最大的数字不超过i的拆分方式的个数。
2. "dp[i][0] = 1;"：初始化动态规划数组，表示数字0的拆分方式只有一种，就是不拆分。
3. "dp[i][j] = dp[i-1][j];"：状态转移方程，表示当前的i大于j，所以拆分方式与i-1时相同。
4. "dp[i][j] = dp[i-1][j] + dp[i][j-i];"：状态转移方程，表示当前的i小于等于j，所以拆分方式为i-1时的拆分方式和j-i时的拆分方式之和。
*/
