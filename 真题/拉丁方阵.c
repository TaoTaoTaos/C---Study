/*拉丁方阵，每一行每一列的数字都不相同的方阵，输入一个n 值输出1 到n 所有形式的拉
丁方阵，列如n=4，其中一种拉丁方阵为
1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3*/

#include <stdio.h>

// 定义一个函数，用于生成拉丁方阵
void latinSquare(int n) {
    // 创建一个n x n的二维数组
    int square[n][n];

    // 使用嵌套的for循环来填充数组
    // 外层循环控制行，内层循环控制列
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 计算每个元素的值
            //!   (i + j) % n + 1   可以确保每一行和每一列的数字都不相同
            square[i][j] = (i + j) % n + 1;

            
        }
    }

    // 打印拉丁方阵
    // 同样使用嵌套的for循环来遍历数组的每一个元素
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 打印当前元素和一个空格
            printf("%d ", square[i][j]);
        }
        // 在打印完一行后，打印一个换行符
        printf("\n");
    }
}

int main() {
    // 定义拉丁方阵的大小
    int n = 4;
    // 调用latinSquare函数来生成并打印拉丁方阵
    latinSquare(n);
    return 0;  // 程序正常结束
}

//在这个程序中，我们首先定义了一个名为latinSquare的函数，
//用于生成拉丁方阵。然后，在main函数中，我们调用这个函数来生成一个4 x 4的拉丁方阵。

/*(i + j) % n + 1这个表达式可以确保生成的拉丁方阵中每一行和每一列的数字都不相同。
这是因为对于任意给定的i（行索引）和j（列索引）
(i + j) % n的结果将在0到n-1之间变化。
然后我们再加上1，使得结果在1到n之间变化，这正好是我们想要在方阵中填充的数字范围。

更具体地说，对于固定的i，
当j从0变化到n-1时，
(i + j) % n + 1的结果将覆盖1到n的所有值，
而不会有重复。同样，对于固定的j，当i从0变化到n-1时，
(i + j) % n + 1的结果也将覆盖1到n的所有值，而不会有重复。
因此，这个表达式可以确保生成的拉丁方阵中每一行和每一列的数字都不相同。
希望这个解释能帮助您理解这个表达式的工作原理。
*/