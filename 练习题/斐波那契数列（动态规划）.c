/*
题目要求：
一个经典的动态规划问题是求解斐波那契数列。斐波那契数列的定义如下：
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2) (n >= 2)

解题思路：
我们可以使用一个一维数组dp来存储中间结果。
dp[i]表示第i个斐波那契数。
初始化时，dp[0] = 0，dp[1] = 1。
状态转移方程为：
dp[i] = dp[i-1] + dp[i-2]
最后返回dp[n]即可。
*/

#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);  // 输入一个正整数n
    int dp[n+1];  // 定义动态规划数组

    // 初始化动态规划数组
    
    dp[0] = 0;  // 第0个斐波那契数为0
    dp[1] = 1;  // 第1个斐波那契数为1

    // 动态规划求解
    for (int i = 2; i <= n; i++)
    {
        dp[i] = dp[i-1] + dp[i-2];  //!     第i个斐波那契数为前两个斐波那契数之和
    }

    printf("%d\n", dp[n]);  // 输出结果

    return 0;
}

/*
总结：
这个题目考察的是动态规划的知识点，通过构建一个一维数组dp，我们可以将问题拆解为更小的子问题，从而避免了重复计算，提高了效率。
关键注释：
1. "int dp[n+1];"：定义了一个一维数组dp，用于存储中间结果。dp[i]表示第i个斐波那契数。
2. "dp[0] = 0; dp[1] = 1;"：初始化动态规划数组，表示第0个和第1个斐波那契数。
3. "dp[i] = dp[i-1] + dp[i-2];"：状态转移方程，表示第i个斐波那契数为前两个斐波那契数之和。
*/
